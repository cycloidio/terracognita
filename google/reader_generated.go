package google

// Code generated by 'go generate'; DO NOT EDIT
import (
	"context"

	"github.com/pkg/errors"

	"google.golang.org/api/compute/v1"
)

// ListInstances will returns a list of Instance within a project and a zone
func (r *GCPReader) ListInstances(ctx context.Context, filter string) (map[string][]compute.Instance, error) {
	service := compute.NewInstancesService(r.compute)

	list := make(map[string][]compute.Instance)
	zones, err := r.getZones()
	if err != nil {
		return nil, errors.Wrap(err, "unable to get zones in region")
	}
	for _, zone := range zones {

		resources := make([]compute.Instance, 0)

		if err := service.List(r.project, zone).
			Filter(filter).
			MaxResults(int64(r.maxResults)).
			Pages(ctx, func(list *compute.InstanceList) error {
				for _, res := range list.Items {
					resources = append(resources, *res)
				}
				return nil
			}); err != nil {
			return nil, errors.Wrap(err, "unable to list compute Instance from google APIs")
		}

		list[zone] = resources
	}
	return list, nil

}

// ListFirewalls will returns a list of Firewall within a project
func (r *GCPReader) ListFirewalls(ctx context.Context, filter string) ([]compute.Firewall, error) {
	service := compute.NewFirewallsService(r.compute)

	resources := make([]compute.Firewall, 0)

	if err := service.List(r.project).
		Filter(filter).
		MaxResults(int64(r.maxResults)).
		Pages(ctx, func(list *compute.FirewallList) error {
			for _, res := range list.Items {
				resources = append(resources, *res)
			}
			return nil
		}); err != nil {
		return nil, errors.Wrap(err, "unable to list compute Firewall from google APIs")
	}

	return resources, nil

}

// ListNetworks will returns a list of Network within a project
func (r *GCPReader) ListNetworks(ctx context.Context, filter string) ([]compute.Network, error) {
	service := compute.NewNetworksService(r.compute)

	resources := make([]compute.Network, 0)

	if err := service.List(r.project).
		Filter(filter).
		MaxResults(int64(r.maxResults)).
		Pages(ctx, func(list *compute.NetworkList) error {
			for _, res := range list.Items {
				resources = append(resources, *res)
			}
			return nil
		}); err != nil {
		return nil, errors.Wrap(err, "unable to list compute Network from google APIs")
	}

	return resources, nil

}

// ListInstanceGroups will returns a list of InstanceGroup within a project and a zone
func (r *GCPReader) ListInstanceGroups(ctx context.Context, filter string) (map[string][]compute.InstanceGroup, error) {
	service := compute.NewInstanceGroupsService(r.compute)

	list := make(map[string][]compute.InstanceGroup)
	zones, err := r.getZones()
	if err != nil {
		return nil, errors.Wrap(err, "unable to get zones in region")
	}
	for _, zone := range zones {

		resources := make([]compute.InstanceGroup, 0)

		if err := service.List(r.project, zone).
			Filter(filter).
			MaxResults(int64(r.maxResults)).
			Pages(ctx, func(list *compute.InstanceGroupList) error {
				for _, res := range list.Items {
					resources = append(resources, *res)
				}
				return nil
			}); err != nil {
			return nil, errors.Wrap(err, "unable to list compute InstanceGroup from google APIs")
		}

		list[zone] = resources
	}
	return list, nil

}

// ListBackendServices will returns a list of BackendService within a project
func (r *GCPReader) ListBackendServices(ctx context.Context, filter string) ([]compute.BackendService, error) {
	service := compute.NewBackendServicesService(r.compute)

	resources := make([]compute.BackendService, 0)

	if err := service.List(r.project).
		Filter(filter).
		MaxResults(int64(r.maxResults)).
		Pages(ctx, func(list *compute.BackendServiceList) error {
			for _, res := range list.Items {
				resources = append(resources, *res)
			}
			return nil
		}); err != nil {
		return nil, errors.Wrap(err, "unable to list compute BackendService from google APIs")
	}

	return resources, nil

}

// ListHealthChecks will returns a list of HealthCheck within a project
func (r *GCPReader) ListHealthChecks(ctx context.Context, filter string) ([]compute.HealthCheck, error) {
	service := compute.NewHealthChecksService(r.compute)

	resources := make([]compute.HealthCheck, 0)

	if err := service.List(r.project).
		Filter(filter).
		MaxResults(int64(r.maxResults)).
		Pages(ctx, func(list *compute.HealthCheckList) error {
			for _, res := range list.Items {
				resources = append(resources, *res)
			}
			return nil
		}); err != nil {
		return nil, errors.Wrap(err, "unable to list compute HealthCheck from google APIs")
	}

	return resources, nil

}
